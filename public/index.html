<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Occupational Safety KPI Report</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #0f172a;
      --card: #ffffff;
      --border-subtle: #e5e7eb;
      --text-main: #111827;
      --text-muted: #6b7280;
      --accent: #2563eb;
      --accent-dark: #1d4ed8;
      --danger: #dc2626;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937, #020617 55%);
      color: var(--text-main);
    }

    .page {
      min-height: 100vh;
      padding: 2rem 1rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    .page-header {
      max-width: 950px;
      text-align: center;
      color: #e5e7eb;
    }

    .page-header h1 {
      font-size: clamp(1.9rem, 3vw, 2.4rem);
      margin-bottom: 0.5rem;
    }

    .page-header p {
      margin: 0;
      font-size: 0.95rem;
      color: #cbd5f5;
    }

    .panel {
      background: var(--card);
      border-radius: 1rem;
      padding: 1.75rem 1.75rem 1.5rem;
      width: 100%;
      max-width: 950px;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.55);
    }

    .panel h2 {
      margin-top: 0;
      margin-bottom: 0.8rem;
      font-size: 1.1rem;
    }

    .panel-subtitle {
      margin-top: 0;
      margin-bottom: 1.3rem;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    .field {
      margin-bottom: 0.9rem;
    }

    .field label {
      display: block;
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
      color: #4b5563;
    }

    .required {
      color: var(--danger);
      margin-left: 0.15rem;
    }

    .field input,
    .field select {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border-radius: 0.55rem;
      border: 1px solid #d1d5db;
      font-size: 0.95rem;
      color: var(--text-main);
      background: #f9fafb;
      min-height: 0;
    }

    .field input::placeholder {
      color: #9ca3af;
    }

    .field input:focus,
    .field select:focus {
      outline: 2px solid rgba(37, 99, 235, 0.3);
      border-color: var(--accent);
      background: #ffffff;
    }

    .field-note {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }

    .file-status {
      font-size: 0.8rem;
      margin-top: 0.3rem;
      color: var(--text-muted);
    }

    .file-status--ok {
      color: #15803d;
    }

    .file-status--error {
      color: #b91c1c;
    }

    .status-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem 1.25rem;
      font-size: 0.85rem;
      color: #4b5563;
      margin-top: 0.35rem;
    }

    .status-filters label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-weight: 500;
    }

    .status-filters input {
      margin: 0;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1.4rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.65rem 1.5rem;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.15s ease;
      user-select: none;
      white-space: nowrap;
    }

    .btn-primary {
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.35);
    }

    .btn-primary:hover {
      background: var(--accent-dark);
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(37, 99, 235, 0.45);
    }

    .btn-outline {
      background: #ffffff;
      color: var(--text-main);
      border-color: #d1d5db;
    }

    .btn-outline:hover {
      background: #f9fafb;
      border-color: #9ca3af;
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-muted);
      border-color: transparent;
      padding-inline: 0;
    }

    .btn-ghost:hover {
      color: var(--text-main);
    }

    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .report {
      margin-top: 0.25rem;
    }

    .report-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.7rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: #eef2ff;
      color: #4f46e5;
    }

    .badge-subtle {
      background: #ecfeff;
      color: #0e7490;
    }

    .meta-line {
      font-size: 0.82rem;
      color: var(--text-muted);
      margin-bottom: 0.4rem;
    }

    #metricsSummary {
      font-size: 0.85rem;
      color: #374151;
      margin-bottom: 0.75rem;
      border-left: 3px solid #e5e7eb;
      padding-left: 0.75rem;
    }

    #metricsSummary strong {
      font-weight: 600;
    }

    #aiReport {
      white-space: pre-wrap;
      font-size: 0.9rem;
      line-height: 1.6;
      color: #111827;
      margin-top: 0.75rem;
    }

    .hidden {
      display: none;
    }

    .loading-dot::after {
      content: "â€¦";
      animation: dots 1s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% {
        content: "";
      }
      40% {
        content: ".";
      }
      60% {
        content: "..";
      }
      80%, 100% {
        content: "...";
      }
    }

    @media (max-width: 640px) {
      .page {
        padding-top: 1.5rem;
      }

      .panel {
        padding: 1.25rem 1rem 1.1rem;
        border-radius: 0.9rem;
      }

      .actions {
        flex-direction: column;
        align-items: stretch;
      }

      .btn {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>

<body>
  <main class="page">
    <header class="page-header">
      <h1>Occupational Safety KPI Report</h1>
      <p>
        Upload your Hailer Excel exports, choose a cost center (KP) and date
        range, and let the app generate an AI-written safety report.
      </p>
    </header>

    <!-- CONTROL PANEL -->
    <section class="panel">
      <h2>1. Data & filters</h2>
      <p class="panel-subtitle">
        This form is tailored for Hailer exports like
        <em>ðŸ¦ºOccupational safety observations_Completed export_YYYY-MM-DD.xlsx</em>.
      </p>

      <form id="controlForm" novalidate>
        <div class="field">
          <label for="excelFiles">
            Hailer Excel exports<span class="required">*</span>
          </label>
          <input
            id="excelFiles"
            type="file"
            accept=".xlsx,.xls"
            multiple
          />
          <div class="field-note">
            You can upload the <strong>Completed</strong>, <strong>In progress</strong>,
            and <strong>New</strong> exports at the same time. Weâ€™ll figure out
            the status from the file names.
          </div>
          <div id="fileStatus" class="file-status">
            No files selected.
          </div>
        </div>

        <div class="grid">
          <div class="field">
            <label for="kpNumber">
              Cost center (KP number)<span class="required">*</span>
            </label>
            <input
              id="kpNumber"
              list="kpOptions"
              placeholder="e.g. KP 88"
              required
            />
            <datalist id="kpOptions"></datalist>
            <div class="field-note">
              Weâ€™ll populate this list from the uploaded files once theyâ€™re read.
            </div>
          </div>

          <div class="field">
            <label>
              Date range to analyze
            </label>
            <div class="grid" style="gap: 0.5rem;">
              <div class="field" style="margin-bottom: 0;">
                <input id="dateFrom" type="date" />
              </div>
              <div class="field" style="margin-bottom: 0;">
                <input id="dateTo" type="date" />
              </div>
            </div>
            <div class="field-note">
              Leave empty to use the earliest and latest dates in the filtered data.
            </div>
          </div>
        </div>

        <div class="field">
          <label>Statuses to include</label>
          <div class="status-filters">
            <label>
              <input type="checkbox" id="statusCompleted" checked />
              Completed
            </label>
            <label>
              <input type="checkbox" id="statusInProgress" checked />
              In progress
            </label>
            <label>
              <input type="checkbox" id="statusNew" checked />
              New
            </label>
          </div>
          <div class="field-note">
            These map automatically from the export file names:
            <em>Completed export / In progress export / New export</em>.
          </div>
        </div>

        <div class="actions">
          <button
            type="button"
            id="analyzeBtn"
            class="btn btn-primary"
          >
            Analyze & generate report
          </button>

          <button
            type="button"
            id="pdfBtn"
            class="btn btn-outline"
            disabled
          >
            Download PDF
          </button>

          <button
            type="button"
            id="resetBtn"
            class="btn btn-ghost"
          >
            Reset
          </button>
        </div>
      </form>
    </section>

    <!-- REPORT PREVIEW -->
    <section
      id="reportPanel"
      class="panel report hidden"
      aria-live="polite"
    >
      <div class="report-toolbar">
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
          <span class="badge">AI report</span>
          <span id="dataBadge" class="badge badge-subtle hidden"></span>
        </div>

        <button
          type="button"
          id="topPdfBtn"
          class="btn btn-outline"
          disabled
        >
          Download PDF
        </button>
      </div>

      <p id="reportMeta" class="meta-line"></p>

      <div id="metricsSummary"></div>

      <div id="aiReport"></div>
    </section>
  </main>

  <!-- Libraries -->
  <!-- SheetJS for reading Excel in browser -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    (function () {
      // ðŸ”§ CHANGE THIS IF YOUR FUNCTION HAS A DIFFERENT NAME
      const AI_FUNCTION_PATH = "/.netlify/functions/chat";

      const excelInput = document.getElementById("excelFiles");
      const fileStatus = document.getElementById("fileStatus");
      const kpInput = document.getElementById("kpNumber");
      const kpOptions = document.getElementById("kpOptions");
      const dateFromInput = document.getElementById("dateFrom");
      const dateToInput = document.getElementById("dateTo");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const pdfBtn = document.getElementById("pdfBtn");
      const topPdfBtn = document.getElementById("topPdfBtn");
      const resetBtn = document.getElementById("resetBtn");

      const statusCompleted = document.getElementById("statusCompleted");
      const statusInProgress = document.getElementById("statusInProgress");
      const statusNew = document.getElementById("statusNew");

      const reportPanel = document.getElementById("reportPanel");
      const reportMeta = document.getElementById("reportMeta");
      const metricsSummary = document.getElementById("metricsSummary");
      const aiReport = document.getElementById("aiReport");
      const dataBadge = document.getElementById("dataBadge");

      let allObservations = [];
      let lastSummary = null;
      let lastReportText = "";

      function updateFileStatus(message, state) {
        fileStatus.textContent = message;
        fileStatus.classList.remove("file-status--ok", "file-status--error");
        if (state === "ok") fileStatus.classList.add("file-status--ok");
        if (state === "error") fileStatus.classList.add("file-status--error");
      }

      function labelStatusFromFileName(name) {
        const lower = name.toLowerCase();
        if (lower.includes("completed")) return "Completed";
        if (lower.includes("in progress") || lower.includes("in_progress"))
          return "In progress";
        if (lower.includes("new")) return "New";
        return "Unknown";
      }

      function parseHailerDate(str) {
        if (!str || typeof str !== "string") return null;
        const trimmed = str.trim();
        if (!trimmed) return null;

        const parts = trimmed.split(/\s+/);
        const datePart = parts[0];
        const timePart = parts[1] || "00:00";

        const datePieces = datePart.split(".").filter(Boolean);
        if (datePieces.length < 3) return null;
        const [dayStr, monthStr, yearStr] = datePieces;
        const day = Number(dayStr);
        const month = Number(monthStr);
        const year = Number(yearStr);

        if (!year || !month || !day) return null;

        const timePieces = timePart.split(":");
        const hour = Number(timePieces[0] || 0);
        const minute = Number(timePieces[1] || 0);

        const d = new Date(year, month - 1, day, hour || 0, minute || 0);
        if (Number.isNaN(d.getTime())) return null;
        return d;
      }

      const COLUMN_MATCHERS = {
        title: [/^Title$/i],
        owner: [/^Owner$/i],
        customerSite: [/^Customer site$/i],
        costCenter: [/^Cost center of the site$/i],
        date: [/^Date$/i],
        category: [/^Category of the observation$/i],
        description: [/^Description of the situation/i],
        opinion: [/^Share your opinion/i],
        measures: [/^Measures taken as a result of the occupational safety observation$/i],
        comments: [/^Comments from the occupational safety organisation$/i],
      };

      function buildColumnMap(headers) {
        const map = {};
        const used = new Set();

        for (const [key, patterns] of Object.entries(COLUMN_MATCHERS)) {
          for (const h of headers) {
            if (used.has(h)) continue;
            if (patterns.some((re) => re.test(h))) {
              map[key] = h;
              used.add(h);
              break;
            }
          }
        }
        return map;
      }

      function loadExcelFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: "array" });
              const sheetName =
                workbook.SheetNames.find((n) =>
                  n.toLowerCase().includes("activities")
                ) || workbook.SheetNames[0];
              const sheet = workbook.Sheets[sheetName];
              const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
              resolve(rows);
            } catch (err) {
              reject(err);
            }
          };
          reader.onerror = () =>
            reject(reader.error || new Error("Could not read file"));
          reader.readAsArrayBuffer(file);
        });
      }

      async function ingestFiles(fileList) {
        allObservations = [];
        lastSummary = null;
        lastReportText = "";
        metricsSummary.textContent = "";
        aiReport.textContent = "";
        reportPanel.classList.add("hidden");
        dataBadge.classList.add("hidden");

        if (!fileList.length) {
          updateFileStatus("No files selected.", null);
          return;
        }

        updateFileStatus("Reading Excel filesâ€¦", "ok");
        const kpSet = new Set();

        for (const file of Array.from(fileList)) {
          try {
            const rows = await loadExcelFile(file);
            if (!rows.length) continue;

            const status = labelStatusFromFileName(file.name);
            const headers = Object.keys(rows[0]);
            const columnMap = buildColumnMap(headers);

            const costKey = columnMap.costCenter;
            const dateKey = columnMap.date;
            const catKey = columnMap.category;
            const siteKey = columnMap.customerSite;

            for (const row of rows) {
              const rawDate = dateKey ? row[dateKey] : undefined;
              const date = parseHailerDate(rawDate);
              if (!date) continue; // skip junk rows

              const costCenter = costKey ? String(row[costKey] || "").trim() : "";
              const title = columnMap.title ? String(row[columnMap.title] || "").trim() : "";
              const description = columnMap.description
                ? String(row[columnMap.description] || "").trim()
                : "";
              const opinion = columnMap.opinion
                ? String(row[columnMap.opinion] || "").trim()
                : "";
              const measures = columnMap.measures
                ? String(row[columnMap.measures] || "").trim()
                : "";
              const comments = columnMap.comments
                ? String(row[columnMap.comments] || "").trim()
                : "";
              const category = catKey ? String(row[catKey] || "").trim() : "";
              const customerSite = siteKey ? String(row[siteKey] || "").trim() : "";
              const owner = columnMap.owner
                ? String(row[columnMap.owner] || "").trim()
                : "";

              if (!title && !description) continue;

              allObservations.push({
                status,
                fileName: file.name,
                costCenter,
                customerSite,
                category,
                title,
                description,
                opinion,
                measures,
                comments,
                owner,
                date,
                rawDate: rawDate || "",
              });

              if (costCenter) kpSet.add(costCenter);
            }
          } catch (err) {
            console.error(err);
            updateFileStatus(
              `Error reading "${file.name}". Some data may be missing.`,
              "error"
            );
          }
        }

        if (!allObservations.length) {
          updateFileStatus(
            "No valid observations found in the uploaded files.",
            "error"
          );
          return;
        }

        const kpValues = Array.from(kpSet).sort();
        kpOptions.innerHTML = "";
        kpValues.forEach((kp) => {
          const opt = document.createElement("option");
          opt.value = kp;
          kpOptions.appendChild(opt);
        });

        updateFileStatus(
          `Loaded ${allObservations.length} observations from ${fileList.length} file(s).`,
          "ok"
        );
      }

      excelInput.addEventListener("change", () => {
        ingestFiles(excelInput.files);
      });

      function enablePdfButtons(enabled) {
        [pdfBtn, topPdfBtn].forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function summariseObservations(observations) {
        const total = observations.length;
        const statusCounts = {};
        const categoryCounts = {};
        const siteCounts = {};

        let earliest = null;
        let latest = null;

        for (const obs of observations) {
          const sKey = obs.status || "Unknown";
          statusCounts[sKey] = (statusCounts[sKey] || 0) + 1;

          if (obs.category) {
            categoryCounts[obs.category] =
              (categoryCounts[obs.category] || 0) + 1;
          }

          if (obs.customerSite) {
            siteCounts[obs.customerSite] = (siteCounts[obs.customerSite] || 0) + 1;
          }

          if (obs.date instanceof Date && !Number.isNaN(obs.date.getTime())) {
            if (!earliest || obs.date < earliest) earliest = obs.date;
            if (!latest || obs.date > latest) latest = obs.date;
          }
        }

        const sortCounts = (map) =>
          Object.entries(map)
            .map(([name, count]) => ({ name, count }))
            .sort((a, b) => b.count - a.count);

        const byStatus = sortCounts(statusCounts);
        const byCategory = sortCounts(categoryCounts);
        const bySite = sortCounts(siteCounts);

        const sampleObservations = observations
          .slice()
          .sort((a, b) => {
            const ta = a.date ? a.date.getTime() : 0;
            const tb = b.date ? b.date.getTime() : 0;
            return tb - ta;
          })
          .slice(0, 20)
          .map((o) => ({
            date: o.date
              ? o.date.toISOString().slice(0, 10)
              : o.rawDate || null,
            status: o.status,
            customerSite: o.customerSite,
            costCenter: o.costCenter,
            category: o.category,
            title: o.title,
            description: o.description,
            opinion: o.opinion,
            measures: o.measures,
          }));

        return {
          totalObservations: total,
          byStatus,
          byCategory,
          bySite,
          dateRange: {
            from: earliest ? earliest.toISOString().slice(0, 10) : null,
            to: latest ? latest.toISOString().slice(0, 10) : null,
          },
          sampleObservations,
        };
      }

      function buildPrompt(kp, filters, summary) {
        const { fromDate, toDate, includedStatuses } = filters;
        const rangeLabel =
          fromDate && toDate
            ? `${fromDate} â€“ ${toDate}`
            : summary.dateRange.from && summary.dateRange.to
            ? `${summary.dateRange.from} â€“ ${summary.dateRange.to}`
            : "full available period";

        const statusLabel = includedStatuses.length
          ? includedStatuses.join(", ")
          : "all statuses";

        return `
You are an occupational safety specialist.

Generate a structured, professional report in English that summarizes occupational safety observations
from Hailer for:

- Cost center (KP): ${kp}
- Statuses included: ${statusLabel}
- Reporting period: ${rangeLabel}

The report should be suitable as a PDF report and include sections like:

1. Overview of observations
2. Status breakdown (new / in progress / completed)
3. Key observation categories and example themes
4. Sites / customer locations with the most observations
5. Notable example observations (briefly)
6. Recommended focus areas and actions for the next period

IMPORTANT:
- Use the numbers and categories from the JSON data below.
- Do NOT invent new numbers â€“ base everything on the data.
- Write in clear, neutral business language.
- You do not need to show the raw JSON.

Here is the aggregated data you should use:

${JSON.stringify(summary, null, 2)}
        `.trim();
      }

      function buildFallbackReport(kp, filters, summary) {
        const { fromDate, toDate, includedStatuses } = filters;
        const rangeLabel =
          fromDate && toDate
            ? `${fromDate} â€“ ${toDate}`
            : summary.dateRange.from && summary.dateRange.to
            ? `${summary.dateRange.from} â€“ ${summary.dateRange.to}`
            : "full available period";

        const statusLabel = includedStatuses.length
          ? includedStatuses.join(", ")
          : "all statuses";

        const topCats = summary.byCategory.slice(0, 5);
        const topSites = summary.bySite.slice(0, 5);

        let text = "";
        text += `OCCUPATIONAL SAFETY KPI REPORT\n\n`;
        text += `Cost center (KP): ${kp}\n`;
        text += `Reporting period: ${rangeLabel}\n`;
        text += `Statuses included: ${statusLabel}\n`;
        text += `Total observations: ${summary.totalObservations}\n\n`;

        text += `1. Status overview\n`;
        summary.byStatus.forEach((item) => {
          text += `- ${item.name}: ${item.count}\n`;
        });
        text += `\n`;

        if (topCats.length) {
          text += `2. Most common observation categories\n`;
          topCats.forEach((item) => {
            text += `- ${item.name}: ${item.count}\n`;
          });
          text += `\n`;
        }

        if (topSites.length) {
          text += `3. Customer sites with most observations\n`;
          topSites.forEach((item) => {
            text += `- ${item.name}: ${item.count}\n`;
          });
          text += `\n`;
        }

        if (summary.sampleObservations.length) {
          text += `4. Sample observations (most recent)\n`;
          summary.sampleObservations.slice(0, 5).forEach((o, idx) => {
            text += `\n${idx + 1}. ${o.date || "Unknown date"} â€“ ${
              o.customerSite || "Unknown site"
            } (${o.category || "No category"})\n`;
            if (o.title) {
              text += `   Title: ${o.title}\n`;
            }
            if (o.description) {
              text += `   Description: ${o.description}\n`;
            }
          });
          text += `\n`;
        }

        text += `5. Summary\n`;
        text += `Based on the available data, the observations highlight key risk areas and opportunities\n`;
        text += `to improve occupational safety within cost center ${kp}. Consider using this report as\n`;
        text += `input for safety walks, toolbox talks, and followâ€‘up planning.\n`;

        return text;
      }

      async function callAiReport(kp, filters, summary) {
        const prompt = buildPrompt(kp, filters, summary);

        try {
          const response = await fetch(AI_FUNCTION_PATH, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ message: prompt }),
          });

          if (!response.ok) {
            throw new Error("Non-200 response from AI function");
          }

          const text = await response.text();
          return text.trim() || null;
        } catch (err) {
          console.error("AI function error:", err);
          return null;
        }
      }

      analyzeBtn.addEventListener("click", async (e) => {
        e.preventDefault();

        if (!allObservations.length) {
          alert("Please upload at least one Hailer Excel export first.");
          return;
        }

        const kp = kpInput.value.trim();
        if (!kp) {
          alert("Please select or type a KP number.");
          kpInput.focus();
          return;
        }

        const includeCompleted = statusCompleted.checked;
        const includeInProgress = statusInProgress.checked;
        const includeNew = statusNew.checked;

        const activeStatuses = [];
        if (includeCompleted) activeStatuses.push("Completed");
        if (includeInProgress) activeStatuses.push("In progress");
        if (includeNew) activeStatuses.push("New");

        if (!activeStatuses.length) {
          alert("Please include at least one status (Completed / In progress / New).");
          return;
        }

        const filteredByKP = allObservations.filter((o) => {
          const cc = (o.costCenter || "").trim().toLowerCase();
          const target = kp.toLowerCase();
          return cc === target;
        });

        if (!filteredByKP.length) {
          alert(`No observations found for KP "${kp}" in the uploaded files.`);
          return;
        }

        const dateFromRaw = dateFromInput.value;
        const dateToRaw = dateToInput.value;

        const fromDate = dateFromRaw ? new Date(dateFromRaw + "T00:00:00") : null;
        const toDate = dateToRaw ? new Date(dateToRaw + "T23:59:59") : null;

        let filtered = filteredByKP.filter((o) =>
          activeStatuses.includes(o.status)
        );

        if (fromDate || toDate) {
          filtered = filtered.filter((o) => {
            if (!o.date) return false;
            const t = o.date.getTime();
            if (fromDate && t < fromDate.getTime()) return false;
            if (toDate && t > toDate.getTime()) return false;
            return true;
          });
        }

        if (!filtered.length) {
          alert(
            "No observations match this KP + date range + status combination. Try widening the filters."
          );
          return;
        }

        const filters = {
          fromDate: dateFromRaw || null,
          toDate: dateToRaw || null,
          includedStatuses: activeStatuses,
        };

        const summary = summariseObservations(filtered);
        lastSummary = summary;

        const total = summary.totalObservations;
        const completedCount =
          summary.byStatus.find((s) => s.name === "Completed")?.count || 0;
        const inProgCount =
          summary.byStatus.find((s) => s.name === "In progress")?.count || 0;
        const newCount =
          summary.byStatus.find((s) => s.name === "New")?.count || 0;

        const rangeLabel =
          filters.fromDate && filters.toDate
            ? `${filters.fromDate}â€“${filters.toDate}`
            : summary.dateRange.from && summary.dateRange.to
            ? `${summary.dateRange.from}â€“${summary.dateRange.to}`
            : "full available period";

        reportMeta.textContent = `KP ${kp} Â· Period: ${rangeLabel} Â· Observations: ${total}`;

        let metricsText = "";
        metricsText += `<strong>Status breakdown:</strong> Completed ${completedCount}, In progress ${inProgCount}, New ${newCount}.<br/>`;

        if (summary.byCategory.length) {
          const topCats = summary.byCategory.slice(0, 3);
          const catParts = topCats.map(
            (c) => `${c.name} (${c.count})`
          );
          metricsText += `<strong>Top categories:</strong> ${catParts.join(
            ", "
          )}.<br/>`;
        }

        if (summary.bySite.length) {
          const topSites = summary.bySite.slice(0, 3);
          const siteParts = topSites.map(
            (s) => `${s.name} (${s.count})`
          );
          metricsText += `<strong>Top customer sites:</strong> ${siteParts.join(
            ", "
          )}.`;
        }

        metricsSummary.innerHTML = metricsText;

        dataBadge.textContent = `${total} observations Â· ${activeStatuses.join(
          ", "
        )}`;
        dataBadge.classList.remove("hidden");

        analyzeBtn.disabled = true;
        analyzeBtn.textContent = "Generating AI report";
        analyzeBtn.classList.add("loading-dot");
        enablePdfButtons(false);
        aiReport.textContent = "Asking AI to generate the reportâ€¦";

        let aiText = await callAiReport(kp, filters, summary);
        if (!aiText) {
          aiText = buildFallbackReport(kp, filters, summary);
        }

        lastReportText = aiText;
        aiReport.textContent = aiText;

        reportPanel.classList.remove("hidden");
        enablePdfButtons(true);

        analyzeBtn.disabled = false;
        analyzeBtn.textContent = "Analyze & generate report";
        analyzeBtn.classList.remove("loading-dot");

        reportPanel.scrollIntoView({ behavior: "smooth" });
      });

      async function makePdf() {
        if (!lastReportText) {
          alert("Generate a report first.");
          return;
        }

        if (!window.jspdf || !window.jspdf.jsPDF) {
          alert(
            "The PDF library did not load. Please check your network connection."
          );
          return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit: "mm", format: "a4" });

        doc.setFont("helvetica", "bold");
        doc.setFontSize(16);
        doc.text("Occupational Safety KPI Report", 15, 18);

        doc.setFont("helvetica", "normal");
        doc.setFontSize(11);

        const meta = reportMeta.textContent || "";
        const metaLines = doc.splitTextToSize(meta, 180);
        let y = 26;
        metaLines.forEach((line) => {
          doc.text(line, 15, y);
          y += 5;
        });

        y += 4;

        const lines = lastReportText.split(/\r?\n/);
        const maxWidth = 180;
        const lineHeight = 5;

        for (const raw of lines) {
          const text = raw || " ";
          const chunks = doc.splitTextToSize(text, maxWidth);
          for (const chunk of chunks) {
            if (y > 280) {
              doc.addPage();
              y = 20;
            }
            doc.text(chunk, 15, y);
            y += lineHeight;
          }
          y += 1;
        }

        const today = new Date().toISOString().slice(0, 10);
        const filename = `safety-kpi-report-${today}.pdf`;
        doc.save(filename);
      }

      [pdfBtn, topPdfBtn].forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          makePdf();
        });
      });

      resetBtn.addEventListener("click", () => {
        excelInput.value = "";
        kpInput.value = "";
        dateFromInput.value = "";
        dateToInput.value = "";
        statusCompleted.checked = true;
        statusInProgress.checked = true;
        statusNew.checked = true;

        allObservations = [];
        lastSummary = null;
        lastReportText = "";

        kpOptions.innerHTML = "";
        fileStatus.textContent = "No files selected.";
        fileStatus.classList.remove("file-status--ok", "file-status--error");

        metricsSummary.textContent = "";
        aiReport.textContent = "";
        reportMeta.textContent = "";
        reportPanel.classList.add("hidden");
        dataBadge.classList.add("hidden");

        enablePdfButtons(false);
      });

      enablePdfButtons(false);
    })();
  </script>
</body>
</html>
